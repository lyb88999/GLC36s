# 使用函数的正确姿势

## 前导内容：函数是一等的公民

> 在Go语言中，函数是一等的公民，函数类型也是一等的数据类型，这是什么意思呢？
>
> 简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。
>
> 而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（功能模块）。
>
> 对于函数类型来说，它是一种对一组输入、输出进行模版化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。

```go
package main

import "fmt"

type Printer func(contents string) (n int, err error)

func printToStd(contents string) (bytesNum int, err error) {
  return fmt.Println(contents)
}

func main() {
  var p Printer
  p = printToStd
  p("something")
}
```

> 这里首先声明了一个函数类型，名为`Printer`。
>
> 在类型声明的名称右边的是`func`关键字，我们由此就可以知道这是一个函数类型的声明。
>
> 而`func`右边的就是这个函数类型的参数列表以及结果列表。
>
> 书写函数签名的方式与函数声明的是一致的。只是紧挨在参数列表左边的不是函数名称，而是关键字`func`。
>
> 注意，各个参数和结果的名称不能算作函数签名的一部分，甚至对于结果声明来说，没有名称都可以。
>
> 只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了统一个函数类型的函数。
>
> 严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。
>
> 我在上面声明的函数`printToStd`的签名与`Printer`的是一致的，因此前者是后者的一个实现，即使它们的名称以及有的结果名称是不同的。
>
> 通过`main`函数中的代码，我们就可以证实这两者的关系了，我顺利地把`printToStd`函数赋给了`Printer`类型的变量p，并且成功地调用了它。



## Q:怎样编写高阶函数？

## A:具体细节如下：

> 什么是高阶函数？简单地说，高阶函数可以满足下面的两个条件：
>
> 1. 接受其他的函数作为参数输入；
> 2. 把其他的函数作为结果返回。
>
> 只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数，高阶函数也是函数式编程中的重要概念和特征。
>
> 具体的问题是，如果想通过编写`calculate`函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出，那么，这样的一个函数该怎么样编写呢？下面是一个典型的回答：

> 首先，我们声明一个叫`operate`的函数类型，它有两个参数和一个结果，都是`int`类型。
>
> ```go
> type operate func(x, y int) int
> ```
>
> 然后，我们编写`calculate`函数的签名部分。这个函数除了需要两个`int`类型的参数之外，还应该有一个`operate`类型的参数。
>
> 该函数的结果应该有两个，一个是`int`类型的，代表真正的操作结果，另一个应该是`err`类型的，因为如果那个`operate`类型的参数值为`nil`，那么就应该直接返回一个错误。
>
> ```go
> func calculate(x int, y int, op operate) (int, error){
>   if op == nil{
>     return 0, errors.New("invalid operation")
>   }
>   return op(x, y), nil
> }
> ```
>
> 上面这个代码体现的Go的特性是：可以把函数作为一个普通的值赋给一个变量。
>
> 在调用`calculate`函数的时候，我们需要传入一个`operate`类型的函数值，这个函数值应该怎么写？
>
> 只要它的签名与`operate`类型的签名一致，并且实现得当就可以了。我们可以像上一个例子那样先声明好一个函数，再把它赋值给一个变量，也可以直接编写一个实现了`operate`类型的匿名函数：
>
> ```go
> op := func(x, y int) int{
>   return x + y
> }
> ```
>
> `calculate`函数就是一个高阶函数。但是我们说高阶函数的特点有两个，而该函数只展示了其中一个特点，即：接受其他的函数作为参数传入。
>
> 另外一个特点，把其他的函数作为结果返回。这个在`demo27.go`中有体现。

## Q:如何实现闭包？

## A:具体如下：

> 闭包是什么？你可以想象一下，在一个函数中存在对外来标识符的引用。所谓的外来标识符，既不代表当前函数的任何参数和结果，也不是函数内部声明的，它是直接从外边拿过来的。
>
> 还有个专门的术语称呼它，叫自由变量，可见它代表的肯定是个变量。实际上，如果它是个常量，那也就形成不了闭包了，因为常量是不可变的程序实体，而闭包体现的却是由“不确定”变为“确定”的一个过程。
>
> 我们说的这个函数（闭包函数）就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态。
>
> 也就是说，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候是未知的。
>
> 即使对于像Go语言这种静态类型的编程语言而言，我们在定义闭包函数的时候最多也只能知道自由变量的类型。

> 在我们刚刚提到的`genCalculator`函数内部，实际上就实现了一个闭包，而`genCalculator`函数也是一个高阶函数。

```go
func genCaculator(op operate) calculatgeFunc {
  return func(x int, y int) (int, error) {
    if op == nil{
      return 0, errors.New("invalid operation")
    }
    return op(x, y), nil
  }
}
```

> `getCalculator`函数只做了一件事，那就是定义一个匿名的、`calculateFunc`类型的函数并把它作为结果值返回。
>
> 而这个匿名的函数就是一个闭包函数。它里面使用的变量`op`既不代表它的任何参数或结果也不是它自己声明的，而是定义它的`genCalculator`函数的参数，所以是一个自由变量。
>
> 这个自由变量究竟代表了什么，这一点并不是在定义这个闭包函数的时候确定的，而是在`getCalculator`函数被调用的时候确定的。
>
> 只有给定了该函数的参数`op`，我们才能知道它返回给我们的闭包函数可以用于什么运算。
>
> 在`if op == nil` 这一行Go语言编译器读到这里时会试图去寻找`op`所代表的东西，它会发现`op`代表的是`getCalcutaor`函数的参数，然后它会把这两者联系起来。这时候可以说，自由变量`op`被“捕获”了。
>
> 当程序运行到这里的时候，`op`就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。
>
> 其实这时我们就是在用高阶函数实现闭包，这也是高阶函数的一大功用。
>
> ![img](https://static001.geekbang.org/resource/image/61/08/61f3689a0023e83407ccae081cdd8108.png?wh=1658*818)
>
> 那么，实现闭包的意义在哪里呢？表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。
>
> 我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。这与设计模式中的“模版方法”有着异曲同工之妙。

## Q：传入函数的那些参数值后来怎么样了？

## A：详情如下：

> 先看一个示例：

```go
package main

import "fmt"

func main() {
  array1 := [3]string{"a", "b", "c"}
  fmt.Printf("The array: %v\n", array1)
  array2 := modifyArray(array1)
  fmt.Printf("The modified array: %v\n", array2)
  fmt.Printf("The original array: %v\n", array1)
}

func modifyArray(a [3]string) [3]string{
  a[1] = "x"
  return a
}
```

> 这个`main`函数中声明了一个数组`array1`，然后把它传给了函数`modify`，`modify`对参数值稍作修改后将其作为结果值返回。`main`函数中的代码拿到这个结果后打印了它（array2），以及原来的数组array1。关键问题是，原数组会因为`modify`函数对参数值的修改而改变吗？
>
> 答案是：原数组不会改变。为什么呢？原因是，所有传给函数的参数值都会被复制，函数在其内部使用的并不是该数值的原值，而是它的副本。
>
> 由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。在`modify`函数中修改的只是原数组的副本而已，并不会对原数组造成任何影响。
>
> 注意，对于引用类型， 比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。
>
> 以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。
>
> 另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。
>
> 比如：

```go
complexArray1 := [3][]string{
  []string{"d", "e", "f"},
  []string{"g", "h", "i"},
  []string{"j", "k", "l"},
}
```

> 变量`complexArray1`是`[3][]string`类型的，也就是说虽然它是一个数组，但是其中的每个元素又是一个切片。这样的一个值被传入函数的话，函数中对该数值的修改会影响到`complexArray1`本身吗？

> 思考题：
>
> 1.`omplexArray1`被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？
>
> 2.函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？
>
> 回答：
>
> 1.分2种情况，若是修改数组中的切片的某个元素，会影响原数组。若是修改数组的某个元素即a[1]=[]string{"x"}就不会影响原数组。谨记Go中都是浅拷贝，值类型和引用类型的区别
>
>  2.当函数返回指针类型时不会发生拷贝。当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝