# 结构体及其方法的使用法门

## 前导内容：结构体类型基础知识

> 一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型。当然了，结构体类型也可以不包含任何字段，这样并不是没有意义的，因为我们还可以为类型关联上一些方法（函数的特殊版本）。
>
> 函数是独立的程序实体，我们可以声明有名字的函数，也可以声明没名字的函数，还可以把它们当作普通的值传来传去。我们能把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出的代表。
>
> 方法却不同，它需要有名字，不能当作值来看待。更重要的是，它必须隶属于某一个类型。方法所属的类型会通过其声明中的接受者声明体现出来。
>
> 接收者声明就是在关键词`func`和方法名称之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。
>
> 举个例子：

```go
// AnimalCategory 代表动物分类学中的基本分类法。
type AnimalCategory struct {
  kingdom string // 界。
  phylum string // 门。
  class  string // 纲。
  order  string // 目。
  family string // 科。
  genus  string // 属。
  species string // 种。
}

func (ac AnimalCategory) String() string {
  return fmt.Sprintf("%s%s%s%s%s%s%s",
    ac.kingdom, ac.phylum, ac.class, ac.order,
    ac.family, ac.genus, ac.species)
}
```

> 结构体类型`AnimalCategory`代表了动物的基本分类法，其中有7个`string`类型的字段，分别表示各个等级的分类。
>
> 下面有个名叫`String`的方法，从它的接收者声明可以看出它隶属于`AnimalCategory`类型。
>
> 通过该方法的接收者名称`ac`，我们可以引用到当前值的任何一个字段，或者调用到当前值的任何一个方法（也包括`String`方法自己）
>
> 这个`String`方法的功能是提供当前值的字符串表示形式，其中的各个等级会按照从大到小的顺序排列。使用时，我们可以这样表示：

```go
category := AnimalCategory{species: "cat"}
fmt.Printf("The animal category: %s\n", category)
```

> 这里，用字面量初始化了一个`AnimalCategory`类型的值，并把它赋给了变量`category`。然后只为其中的`species`字段指定了字符串值“cat”。
>
> 在Go语言中，我们可以通过为一个类型编写名为`String`的方法，来定义该类型的字符串表示形式。这个`String`方法不需要任何参数声明，但需要有一个`string`类型的结果声明。
>
> 正因为如此，在调用`fmt.Printf`函数时，使用占位符`%s`和`category`值本身就可以打印出后者的字符串表示形式，而无需显式调用它的`String`方法。
>
> `fmt.Printf`函数会自己去寻找它。此时的打印内容会是`The animal category: cat`。显而易见，`category`的`String`方法成功地引用了当前值的所有字段。

> 方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。
>
> 一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。
>
> 我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。
>
> Go 语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go 语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。

> 现在让我们再把目光放到结构体类型的字段声明上。我们来看下面的代码：

```go
type Animal struct {
  scientificName string // 学名。
  AnimalCategory    // 动物基本分类。
}
```

> 这个结构体类型名为`Animal`，它有两个字段，一个是`string`类型的字段`scientificName`，代表了动物的学名，另一个字段声明中只有`AnimalCategory`，它正是前面的那个结构体名字，这是什么意思？

## Q：`Animal`类型中的字段声明`AnimalCategory`代表了什么？

## A：典型回答：字段声明`AnimalCategory`代表了`Animal`类型的一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟"."，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。

## 问题解析：

>  `Animal`类型有个方法叫`Category`，它是这么写的：

```go
func (a Animal) Category() string{
  return a.AnimalCategory.String()
}
```

>  `Category`方法的接收者是`Animal`，接收者名称是`a`。在该方法中，通过表达式`a.AnimalCategory`选择到了`a`的这个嵌入字段，然后又选择了该字段的`String`方法并调用了它。
>
> 实际上，把一个结构体类型嵌入到另一个结构体类型中的意义不止如此。嵌入字段的方法集合会被无条件地被嵌入类型的方法集合中。例如下面这种：

```go
animal := Animal{
  scientificName: "American Shorthair",
  AnimalCategory: category, // 第一次见这种写法 原来嵌入字段也可以赋值
}
fmt.Printf("The animal: %s\n", animal)
```

> 在这里声明了一个`Animal`类型的变量`animal`并对它进行初始化，把字符串值`American Shorthair`赋值给它的字段`scientificName`，并把前面声明过的变量`category`赋值给它的嵌入字段`AnimalCategory`。
>
> 在后面使用`fmt.Printf`函数和`%s`占位符试图打印`animal`的字符串表示形式，相当于调用`animal`的`String`方法，虽然我们还没有为`Animal`类型编写`String`方法，但这样做是没问题的。因为在这里嵌入字段`AnimalCategory`的`String`方法会被当作`animal`的方法调用。

> 那么如果为`Animal`类型也编写一个`String`方法，这里会调用哪一个呢？
>
> 答案是，`animal`的`String`方法被调用。这时，我们说，嵌入字段`AnimalCategory`的`String`方法被“屏蔽”了。注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。
>
> 类似的，由于我们同样可以像访问嵌入类型的字段那样，直接访问嵌入的字段的字段，所以如果两个结构体类型中存在同名的字段，那么嵌入字段中的那个字段一定会被“屏蔽”。
>
> 正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。
>
> 不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法。其实这种“屏蔽”也带来了一些好处，比如下面这个`Animal`类型的`String`方法的实现：

```go
func (a Animal) String() string {
  return fmt.Sprintf("%s (category: %s)",
    a.scientificName, a.AnimalCategory)
}
```

> 在这里，我们把对嵌入字段的`String`方法的调用结果融入到了`Animal`类型的同名方法的结果中。这种将同名方法的结果逐层“包装”的手法是常见的和有用的，也算是一种惯用法了。
>
> ![img](https://static001.geekbang.org/resource/image/47/b2/471b42767d0c82af8acd22c13dfd33b2.png?wh=1920*941)
>
> 最后，还要提一下多层嵌入的问题（嵌入字段本身也有嵌入字段的情况），看下面的`Cat`类型：

```go
type Cat struct {
  name string
  Animal
}

func (cat Cat) String() string {
  return fmt.Sprintf("%s (category: %s, name: %q)",
    cat.scientificName, cat.Animal.AnimalCategory, cat.name)
}
```

> 结构体类型`Cat`中有一个嵌入字段`Animal`，而`Animal`类型还有一个嵌入字段`AnimalCategory`。
>
> 在这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入的层级越深的字段或方法越可能被“屏蔽”。
>
> 如果该类型没有`String`方法，那么嵌入字段`Animal`的`String`方法会被调用，而它的嵌入字段`AnimalCategory`的`String`方法仍然会被屏蔽。
>
> 只有当`Cat`类型和`Animal`类型都没有`String`方法的时候，`AnimalCategory`的`String`方法才会被调用。

## Q：Go语言是用嵌入字段实现了继承吗？

## A：详情如下：

> Go语言中没有继承的概念，它所做的只是通过嵌入字段的方式实现了类型之间的组合，
>
> 面向对象编程中的继承，是通过侵入的方式来实现的；而类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。
>
> 同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。
>
> 我们要做的只是把类型当作字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或者“屏蔽”的方式去调整和优化。
>
> 另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。
>
> 这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。

## Q：值方法和指针方法都是什么意思，有什么区别？

## A：详情如下：

> 我们都知道，方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。
>
> 比如，我们在前面为`AnimalCategory`、`Animal`以及`Cat`类型声明的那些方法都是值方法。那么什么叫指针类型，什么是指针方法呢？
>
> ```go
> func (cat *Cat) SetName(name string){
>   cat.name = name
> }
> ```
>
> 方法`SetName`的接收者类型是`*cat`，`Cat`左边再加个`*`代表的就是`Cat`类型的指针类型。
>
> 所谓的指针方法，就是接收者类型是上述指针类型的方法。
>
> 那么值方法和指针方法之间有什么不同点呢？它们的不同如下所示：
>
> 1. 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型的别名类型。而指针方法的接收者，是该方法所属的那个基本类型的指针值的一个副本，我们在这样的方法内对该副本指向的值进行修改，一定会体现在原值上。
> 2. 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。严格来讲，我们在这样的 基本类型的值上只能调用到它的值方法，但是Go语言会适时地为我们自动地转译，使得我们在这样的值上面也能调用到它的指针方法。
> 3. 在后边你会了解到，一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息相关的。如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量就也会有差异，除非这两个数量都是零。比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的实现类型。