# 通道的高级玩法

> 首先说说单向通道，我们在说“通道”的时候指的都是双向通道，也就是既可以收也可以发的通道。
> 
> 所谓单向通道就是，只能发不能收，或者只能收不能发的通道。一个通道是双向的还是单向的是由它的类型字面量体现的
> 
```go
var uselessChan = make(chan<- int, 1)
```
>上面声明并初始化了一个名为`uselessChan`的变量，这个变量的类型是`chan<- int`，容量是`1`。
> 
> `chan<- `表示该通道是单向的，只能发不能收；类似的，如果是`<-chan`，则表示只能收不能发。所以前者可以被称为发送通道，后者可以被称为接收通道。
> 
> 需要注意的是，这里的“发”和“收”都是站在操作通道的代码的角度上说的，也就是只能向通道“发”，或者只能从通道“收”。


## Q:单向通道有什么价值？
## A:单向通道的主要的用途就是约束其他代码的行为。
## 问题解析:如下

> 先看下面的代码
> 
```go
func SendInt(ch chan<- int){
	ch <- rand.Intn(1000)
}
```
> 这个叫`SendInt`的函数只接收一个`chan<- int`类型的参数。在这个函数中的代码只能向参数`ch`发送元素值，而不能从它那里接收元素值。这就起到了约束函数行为的作用。
> 
> 在实际场景中，这种约束一般会出现在接口类型声明中的某个方法定义上。如下:
> 
```go
type Notifier interface{
	SendInt(ch chan<- int)
}
```
> 一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现类型做出约束。
> 
> 在这里，`Notifier`接口中的`SendInt`方法只会接受一个发送通道作为参数。因此，在该接口的所有实现类型中的`SendInt`方法都会受到限制。
> 
> 我们在调用`SendInt`函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为Go在这种情况下会自动把双向通道转换为函数所需要的单向通道。
```go
intChan1 := make(chan int, 3)
sendInt(intChan1)
```
> 在另一方面，我们还可以在函数声明的结果列表中使用单向通道。如下:
>
```go
func getIntChan() <-chan int{
	num := 5
	ch := make(chan int, num)
	for i:=0; i<num; i++{
		ch <- i
	}
	close(ch)
	return ch
}
```
> 函数`getIntChan`会返回一个`<-chan int`类型的通道，这意味着得到该通道的程序只能从该通道中接收值，这实际上就是对函数调用方的一种约束了。
> 
> 另外，我们在Go语言中还可以声明函数类型，如果我们在函数类型中使用了单向通道，那么就相当于在约束所有实现了这个函数类型的函数。
> 
> 再看一下调用`getIntChan`函数的代码:
> 
```go
intChan2 := getIntChan()
for elem := range intChan2{
	fmt.Printf("The element in intChan2: %v\n",elem)
}
```
> 用`for`语句循环地取出了该通道中的所有元素值，并打印出来。
> 
> 现在需要直到关于这个`for`语句的三件事:
> 
> 1.上述`for`语句会不断地尝试从通道`intChan2`中取出元素值。即使`intChan2`已经被关闭了，它也会在取出所有剩余的元素值之后再结束执行。
> 2.通常，当通道`intChan2`中没有元素时，这条`for`语句会被阻塞在有`for`关键字那一行，直到有新的元素值可取。不过，由于这里的`getIntChan`函数会事先将`intChan2`关闭，所以它在取出`intChan2`中的所有元素值之后会立马结束运行。
> 3.倘若通道`intChan2`的值为`nil`，那么这条`for`语句会被永远地阻塞在有`for`关键字的那一行。

这就是带`range`语句的`for`语句与通道的联用方式。不过，它是一种用途比较广泛的语句，还可以被用来从其他一些类型的值中获取元素。除此之外，Go语言还有一种专门为了操作通道而存在的语句：`select`语句。



## Q:select语句与通道怎样联用，应该注意些什么？

## A:问题解析如下

> `select`语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。

> `select`语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字`case`开头，后跟一个`case`表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。

> 默认分支其实就是 default case，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字`default`开头并直接后跟一个冒号。同样的我，我们可以在`default:`的下一行写入要执行的语句。

> 由于`select`语句是专为通道设计的，所以每个`case`表达式中都只能包含操作通道的表达式，比如接收表达式。

> 当然，如果我们需要把接收表达式的结果赋给变量的话，还可以把这里写成赋值语句或者短变量声明。下面是一个简单的例子：

```go
// 准备好几个通道
intChannels := [3]chan int{
  make(chan int, 1),
  make(chan int, 1),
  make(chan int, 1),
}
// 随机选择一个通道，并向它发送元素值
index := rand.Intn(3)
fmt.Printf("The inde: %d\n", index)
intChannels[index] <- index
// 哪一个通道中有可取的元素，哪个对应的分支就会被执行
select {
case <-intChannels[0]:
  fmt.Println("The first candidate case is selected.")
case <-intChannels[1]:
  fmt.Println("The second candidate case is selected.")
case elem := <-intChannels[2]:
  fmt.Printf("The third candidate case is selected, the element is %d.\n", elem)
default:
  fmt.Println("No candidate case is selected!")
}
```

> 在使用`select`语句的时候，我们首先需要注意下面几个事情。
>
> 1. 如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，`select`语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。
> 2. 如果没有加入默认分支，那么一旦所有的`case`表达式都没有满足求值条件，那么`select`语句就会被阻塞。直到至少有一个`case`表达式满足条件为止。
> 3. 我们可能会因为通道关闭了，而直接从通道接收到一个其元素的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。
> 4. `select`语句只能对其中的每一个`case`表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在`for`语句中嵌入`select`语句的方式实现。但这时要注意，简单地在`select`语句的分支中使用`break`语句，只能结束当前的`select`语句的执行，而并不会对外层的`for`语句产生作用，这种错误的用法可能会让这个`for`语句无休止地执行下去。

```go
intChan := make(chan int, 1)
// 一秒后关闭通道。
time.AfterFunc(time.Second, func() {
  close(intChan)
})
select {
case _, ok := <-intChan:
  if !ok {
    fmt.Println("The candidate case is closed.")
    break
  }
  fmt.Println("The candidate case is selected.")
}
```

## Q:`select`语句的分支选择规则有哪些？

## A:规则如下面所示:

> 1. 对于每一个`case`表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果`case`表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的`case`表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。(demo可以看上面那个代码块)
> 2. `select`语句包含的候选分支中的`case`表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在`select`语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。
> 3. 对于每一个`case`表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该`case`表达式的求值就是不成功的。在这种情况下，我们可以说，这个`case`表达式所在的候选分支是不满足选择条件的。
> 4. 仅当`select`语句中的所有`case`表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么`select`语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，`select`语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。
> 5. 如果`select`语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使`select`语句是在被唤醒时发现的这种情况，也会这样做。
> 6. 一条`select`语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。
> 7. `select`语句的每次执行，包括`case`表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的`case`表达式以及分支中，是否包含并发不安全的代码了。

> 思考题：如果在select语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支？
>
> 回答：当第二个boolean参数为false的时候，在相应的case中设置chan为nil零值，再次case求值的时候会遭遇阻塞，会屏蔽该case。
