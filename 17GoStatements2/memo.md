# Go语句及其执行规则（下）

## Q：怎样才能让主goroutine等待其他goroutine？

## A：详情如下：

>  上节已经说过，一旦主goroutine中的代码执行完毕，当前的Go程序就会结束运行，无论其他的goroutine是否已经在运行了。那么，怎样才能做到等其他的goroutine运行完毕之后，再让主goroutine结束运行呢？
>
> 其中最简单粗暴的办法就是让主goroutine“小睡”一会儿。

```go
for i := 0; i < 10; i++{
  go fun(){
    fmt.Println(i)
  }()
}
time.Sleep(time.Millisecond * 500)
```

> 我们可以把一个相对的时间传给该函数，就像这里的“500毫秒”。`time.Sleep`函数会在被调用时用当前的绝对时间，再加上相对时间计算出在未来的恢复运行时间。显然，一旦到达恢复运行时间，当前的goroutine就会从“睡眠”中醒来，并开始继续执行后面的代码。
>
> 这个办法是可行的，只要“睡眠”的时间不要太短就好。不过，问题恰恰就在这里，我们让主 goroutine“睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的 goroutine 运行完毕，而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。
>
> 既然不容易预估时间，那就让其他的goroutine在运行完毕时候告诉我们就好了。这个思路很好，那怎么做呢？
>
> 我们先创建一个通道，它的长度应该与我们手动启用的goroutine的数量一致。在每个手动启用的goroutine即将运行完毕的时候，我们都要向该通道发送一个值。
>
> 注意，这些发送表达式应该被放在它们的`go`函数体的最后面。对应的，我们还需要在`main`函数的最后从通道接收元素值，接收的次数也应该与手动启用的goroutine的数量保持一致。
>
> 当然还可以用`sync.Waitgroup`，这个在之后说。

## Q：怎样让我们启用的多个goroutine按照既定的顺序运行？

## A：详情如下：

> 基于上一篇主题中的代码，怎样做到让从`0`到`9`这几个整数按照自然数的顺序打印出来呢？
>
> 首先，我们需要稍微改造一下`for`语句中的`go`函数，要让它接受一个`int`类型的参数，并在调用它的时候把变量`i`的值传进去。为了不改动这个`go`函数中的其他代码，我们可以把它的这个参数也命名为`i`。

```go
for i := 0; i < 10; i++{
  go func(i int){
    fmt.Println(i)
  }(i)
}
```

> 只有这样，Go语言才能保证每个goroutine都可以拿到一个唯一的整数。
>
> 在`go`语句被执行时，我们传给`go`函数的参数`i`会先被求值，如此就得到了当次迭代的序号。之后，无论`go`函数在什么时候执行，这个参数值都不会变。
>
> 然后，再着手改造`for`语句中的`go`函数。

```go
for i := uint32(0); i < 10; i++ {
  go func(i uint32) {
    fn := func() {
      fmt.Println(i)
    }
    trigger(i, fn)
  }(i)
}
```

> 首先在`go`函数中先声明了一个匿名的函数，并把它赋给了变量`fn`。这个匿名函数只是调用`fmt.Println`函数以及打印`go`函数的参数`i`的值。
>
> 在这之后调用了一个名为`trigger`的函数，并把`go`函数的参数`i`和刚刚声明的变量`fn`作为参数传给了它。注意，`for`语句声明的局部变量`i`和`go`函数的参数`i`的类型都变了，由`int`变为了`uint32`。
>
> 再看`trigger`函数，该函数接受两个参数，一个是`uint32`类型的参数`i`，另一个是`func()`类型的参数`fn`。

```go
trigger := func(i uint32, fn func()) {
  for {
    if n := atomic.LoadUint32(&count); n == i{
      fn()
      atomic.AddUint32(&count, 1)
      break
    }
    time.Sleep(time.Nanosecond)
  }
}
```

> `trigger`函数会不断地获取一个名为`count`的变量的值，并判断该值是否与参数`i`的值相同。如果相同，那么就立即调用`fn`代表的函数，然后把`count`变量的值加`1`，最后显式地退出当前的循环。否则，我们就让当前的goroutine“睡眠”一个纳秒再进入下一个迭代。
>
> 注意，在操作`count`的时候使用的都是原子操作，这是由于`trigger`函数会被多个goroutine并发地调用，所以它用到的非本地变量`count`，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件，破坏了程序的并发安全性。
>
> 所以，我们总是应该对这样的操作加以保护，在`sync/atomic`包中声明了很多用于原子操作的函数。
>
> 另外，由于选用的原子操作函数对被操作的数值的类型有约束，所以才对`count`以及相关的变量和参数进行了统一的变更（`int`->`uint32`）。
>
> 这里的`trigger`函数实现了一种自旋：除非发现条件已满足，否则它会不断进行检查。
>
> 经过上述的改造，就使得异步发起的`go`函数得到了同步地执行。