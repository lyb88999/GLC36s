# 接口类型的合理运用

## 正确使用接口的基础知识

> 在Go语言的语境中，接口类型与其他数据类型不同，因为它是无法被实例化的。更具体地说，我们既不能通过调用`new`函数或`make`函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。
>
> 通过关键字`type`和`interface`，我们可以声明出接口类型。
>
> 接口类型的类型字面量与结构体类型的看起来有些相似，它们都用花括号包裹一些核心信息。只不过，结构体类型包裹的是它的字段声明，而接口类型包裹的是它的方法定义。
>
> 接口类型声明中的这些方法所代表的就是该接口的方法集合；对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征，那么它就一定是这个接口的实现类型。

```go
type Pet interface{
  SetName(name string)
  Name() string
  Category() string
}
```

> 上面声明了一个接口类型`Pet`，它包含了3个方法定义，方法名称分别为`SetName`、`Name`和`Category`，这三个方法共同组成了接口类型`Pet`的方法集合。
>
> 只要一个数据类型的方法集合中有这3个方法，那么它就一定是`Pet`接口的实现类型，这是一种无侵入式的接口实现方式。（鸭子类型）
>
> 那么如何判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？
>
> 这里有两个充要条件：一是“两个方法的签名需要完全一致”，另一个是“两个方法的名称”要一模一样。
>
> 在`demo31.go`中，`Dog`类型本身的方法集合中只包含了两个方法，也就是所有的值方法。而它的指针类型`*Dog`方法集合却包含了三个方法。
>
> 也就是说，它拥有`Dog`类型附带的所有值方法和指针方法，又由于这3个方法恰恰分别是`Pet`接口中某个方法的实现，所以`*Dog`类型就成为了`Pet`接口的实现类型。

```go
dog := Dog{"little pig"}
var pet Pet = &dog
```

> 对于一个接口类型的变量来说，例如上面的变量`pet`，我们赋给它的值可以被叫作它的实际值（或者动态值），而该值的类型可以被叫作这个变量的实际类型（或者动态类型）。
>
> 动态类型的这个叫法是相对于静态类型而言的，对于变量`pet`来讲，它的静态类型就是`Pet`，并且永远是`Pet`，但是它的动态类型会随着我们赋给它的动态值而变化。
>
> 还有，在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。

## Q： 当我们为一个接口变量赋值时会发生什么？

## A：详情如下：

> 为了突出问题，首先把`Pet`接口的声明简化了一下：

```go
type Pet interface{
  Name() string
  Category() string
}
```

> 在这个新的`Pet`接口中，去掉了`SetName`方法，这样一来，`Dog`类型也就变成`Pet`接口的实现类型了。
>
> 现在，我先声明并初始化了一个`Dog`类型的变量`dog`，这时它的`name`字段是`"little pig"`。然后，把该变量赋给了一个`Pet`类型的变量`pet`。然后调用`dog`的方法`SetName`把它的`name`字段的值改为了`"monster"`。

```go
dog := Dog{"little pig"}
var pet Pet = dog
dog.SetName("monster")
```

> 那么，上述代码执行之后，`pet`变量的字段`name`的值是什么？
>
> 答案是：`pet`变量的字段`name`的值依然是`"little pig"`。

## 问题解析

> 首先，由于`dog`的`SetName`方法是指针方法，所以该方法的接收者就是指向`dog`的指针值的副本，因此其中对接收者的`name`字段的设置就是对变量`dog`的变动。那么当`dog.SetName("monster")`执行之后，`dog`的`name`字段的值就一定是`"monster"`。
>
> 那为什么`dog`的`name`字段变了，而`pet`的却没变呢？这里有一条通用的规则：如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是这个值的一个副本。
>
> 当知道了这条通用规则之后，确实可以做对前面那道题，但这只是这个问题的其中一个原因。
>
> 那么另一半原因是什么？这就需要从接口类型值的存储方式和结构说起了。前面说过，接口类型本身无法被值化。我们在赋予它实际的值之前，它的值一定是`nil`，这也是它的零值。
>
> 不过要注意，即使我们像前面那样把`dog`的值赋给了`pet`，`pet`的值与`dog`的值也是不同的，这不仅仅是副本与原值的那种不同。
>
> 当我们给一个接口变量赋值的时候，该变量的动态类型会和它的动态值一起被存储在一个专用的数据结构中。
>
> 严格来讲，这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量的那个实际的值。所以才说`pet`的值与`dog`的值肯定是不同的，无论是从它们存储的内容还是存储的结构上来看都是如此。
>
> 比如把这个专用的数据结构叫作`iface`，在Go语言的`runtime`包中就是这么叫的。
>
> `iface`的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径等等。
>
> 总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。

## Q：接口变量的值在什么情况下才真正为`nil`

## A：详情如下：

对于一个引用类型的变量，它的值是否为`nil`完全取决于我们赋给了它什么，是这样吗？

我们先来看一段代码：

```go
var dog1 *Dog
fmt.Println("The first dog is nil. [wrap1]")
dog2 := dog1
fmt.Println("The second dog is nil. [wrap1]")
var pet Pet = dog2
if pet == nil {
  fmt.Println("The pet is nil. [wrap1]")
} else {
  fmt.Println("The pet is not nil. [wrap1]")
}
```

在这段代码中，先声明了一个`*Dog`类型的变量`dog1`，并没有对它进行初始化。这时变量的值是什么，显然是`nil`，然后把该变量的值赋给了`dog2`，后者的值此时也必定是`nil`，是这样吗？

那么问题来了：当把`dog2`赋给`Pet`类型的变量`pet`之后，变量`pet`的值是什么呢？是`nil`吗？

当我们把`dog2`的值赋给变量`pet`的时候，`dog2`的值会先被复制；然后，Go语言会用上面提到的那个专用数据结构`iface`的实例包装这个`dog2`值的副本，这里是`nil`。

虽然被包装的动态值是`nil`，但是`pet`的值却不是`nil`，因为这个动态值只是`pet`值的一部分而已。

这时`pet`的动态类型就存在了，是`*Dog`。换个角度来看，我们把`nil`赋给了`pet`，但是`pet`的值却不是`nil`。

只要我们把一个有类型的`nil`赋给接口变量，那么这个变量的值一定不会是真正的那个`nil`。因此，当我们用判等符号`==`判断`pet`是否与字面量`nil`相等的时候，答案一定是`false`。

那么，如何让一个接口变量的值真正为`nil`呢？要么只声明但不做初始化，要么直接把字面量`nil`赋给它。

## Q：怎样实现接口之间的组合？

## A：详情如下：

> 接口类型间的嵌入也被称为接口的组合。
>
> 接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此，因此，接口的组合根本不可能导致“屏蔽”现象的出现。
>
> 与结构体类型的嵌入很相似，我们只要把一个接口类型的名称直接写到另一个接口类型的成员列表中就可以了。如下：

```go
type Animal interface{
  ScientificName() string
  Category() string
}

type Pet interface{
  Animal
  Name() string
}
```

> 接口类型`Pet`包含了两个成员，一个是代表了另一个接口类型的`Animal`，一个是方法`Name`的定义。此时，`Animal`接口包含的所有方法也就成了`Pet`接口的方法。
>
> 总之，善用接口组合和小接口可以让你的程序框架更加稳定和灵活。



