## Q:对通道的发送和接收操作都有哪些基本的特性？
## A:基本特性如下:
### 1.对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
> 在同一时刻，Go语言的运行时系统只会执行对同一个通道的任意个发送操作中的某一个。</br>
> 
> 直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</br>
> 
> 类似的，在同一时刻，运行时系统也只会执行对同一个通道的任意个接收操作中的一个。</br>
> 
> 直到这个元素值被完全移出该通道之后，其他针对该通道的接收操作才可能被执行，即使这些操作是并发执行的也是如此。</br>
> 
> 这里的所谓的并发执行，可以认为是多个代码块在不同的goroutine中，并有机会在同一个时间段内被执行。</br>
> 
> 另外，对于通道中的同一个元素值来说，发送操作和接收操作也是互斥的
> 
> 还要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的值并不是在接收操作符右边的那个元素值，而是它的副本。
> 
> 另一方面，元素值从通道进入外界时会被移动。这个移动实际上包括了两步，第一步是生成正在通道中的这个值的副本，并准备给到接收方；第二步是删除在通道中的这个元素值。
### 2.发送操作和接收操作中对元素值的处理都是不可分割的。
> 这里“不可分割”的意思是它们处理元素值时都是一气呵成的，绝不会被打断。
> 
> 例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。
> 
> 又例如，接收操作在准备好元素的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。
> 
> 这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。
### 3.发送操作在完全完成之前会被阻塞，接收操作也是如此。
> 一般情况下，发送操作包含了“复制元素值”和“放置副本到通道内部”这两个步骤。
> 
> 在这两个步骤完全完成之前，发起这个发送指令的那句代码会一直阻塞在那里。也就是说，在它以后的代码都不会有执行的机会，直到这句代码的阻塞解除。
> 
> 更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的goroutine，以使它去争取继续运行代码的机会。
> 
> 另外，接收操作通常包含了“复制通道内的元素值”、“放置副本到接收方”和“删除原值”三个步骤。
> 
> 在这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的goroutine接收到了运行时系统的通知并重新获得运行机会为止。

## Q:发送操作和接收操作在什么时候可能被长时间阻塞？
## A:如下

> 先说针对缓冲通道的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素被接收走。
> 
> 这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。
> 
> 由于发送操作在这种情况下被阻塞后，它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。
> 
> 相对的，如果通道为空，那么对它的所有接收操作都会被阻塞，直到通道中有新元素值出现。这时，通道会通知最早等待的那个接收者所在的goroutine，并使它再次执行接收操作。
> 
> 因此等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。
>
> 对于非缓冲通道，情况要简单一些。无论是发送还是接收操作，一开始执行就会被阻塞，直到配对的操也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。
> 
> 并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。
> 
> 在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。
> 
> 但是，当发送操作在执行的时候发现空的通道中正好有等待接收的操作，那么它会直接把元素复制给接收方(同非缓冲通道类似)。
> 
> 上面都是正常使用通道的前提下会发生的事情，如果错误使用通道可能造成阻塞:
> 
> 对于值为nil的通道，不管它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。
> 
> 注意，由于通道类型是引用类型，所以它的零值就是`nil`。换句话说，当我们只声明该类型的变量但没有用`make`函数对它进行初始化时，该变量的值就是`nil`。
> 


## Q:发送和接收操作会在什么时候引发panic？
## A:如下:

> 对于一个已经初始化，但未关闭的通道来说，收发操作一定不会引发panic。但是通道一旦关闭，再对它进行发送操作，就会引发panic。
> 
> 另外，如果我们试图关闭一个以及关闭了的通道，也会引发panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。
> 
> 更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就一定是bool类型。它的值如果为false就说明通道已关闭，并且再没有元素可取了。
> 
> 注意，如果通道关闭时，里面还有元素未取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。
> 
> 因此，通过接收表达式的第二个结果值，来判断通道是否关闭可能是有延时的。
> 
> 由于通道的收发有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应该让发送方来做这件事。